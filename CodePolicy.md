
Политика работы с репозиторием
------------------------------
<ol>
 <li>Не нарушать нейминг (о нем ниже)</li>
 <li>Не нарушать структуру каталогов (о ней ниже)</li>
 <li>Не добавлять в репозиторий то, что не является его семантической</li>
    частью
 <li>Не посылать коммиты в master никогда</li>
 <ul>
  <li>Данные в master будут появляться путем слияния с какой-либо веткой</li>
  <ul>
    <li>Если нашли ошибку, Если новая задача</li>
    <li>Новая ветка</li>
    <li>Решение ошибки</li>
    <li>Ревью</li>
    <li>Слияние с master</li>
  </ul>
  </ul>
<li>Не вносить изменения в чужой код самостоятельно</li>
<ul>
  <li>Очевидная ошибка, Логическая ошибка, Не оптимальное решение</li>
  <ul>
    <li>Комментарий во время ревью</li>
    <li>Комментарий после коммита</li>
    <li>Сообщение в чат (Telegram)</li>
    <li>Звонок по середине ночи</li>
    <li>Угрозы любого характера</li>
    <li>НО НЕ ТРОГАТЬ ЧУЖОЙ КОД</li>
  </ul>
</ul>
<li>Не удалять файлы</li>
  <ul>
    <li>Если какой-либо файл стал не нужен удалять его только через отдельную ветку и после того как все подтвердят что он не нужен</li>
  </ul>
<li>В начале каждого файла с исходным кодом должна быть шапка</li>
  <ul>
    <li>Назначение файла - короткое сообщение (не название) о том что в этом файле находится</li>
    <li>Автор файла в формате: Фамилия Имя Отчество (ник на github)</li>
    <li>Дата создания файла: дата когда файл был создан</li>
  </ul>
</ol>

----------
**Нейминг**
*Названия файлов и папок* в **нижнем регистре** - если иного не требует система, например, если папка является папкой класса в исходных кодах, она должна называться как этот класс

*Названия переменных* - Camel Case - первое слово в названии переменной с маленькой, остальные слова с большой без разделителей, если название переменной получается длинным, то приветствуется сокращение слов составляющих название переменной до согласной буквы. Не рекомендуется выкидывать слова из названия совсем. Приоритетом является понятность, на втором месте длинна.

*Название функций* - Camel Case - первое слово в названии функции с маленькой, остальные слова с большой без разделителей

*Название класса, структуры* - Camel Case - каждое слово с большой буквы

*Название констант* - Underline Upper Case - каждое слово в названии константы с большой буквы, слова разделены нижним подчеркиванием

*Название приватных полей и методов* - Underline Lower Case - все слова в нижнем регистре разделены нижним подчеркиванием, в случае когда на приватное поле есть функция геттер, тогда это поле должно начинаться с нижнего подчеркивания, а функция геттер носить его название. 

*Название публичных полей и методов* - Camel Case - первое слово в названии поля или метода с маленькой, остальные слова с большой без разделителей

    const int PI = 3.1415;
    
    void printVector( const std::vector< int >& listProducts  );
    
    class SomeClass
    {
    public:
    	SomeClass() { ... }
    	void price() const 
    	{
    		return _price;
    	}
    	void setPrice(int price)
    	{
	    	if(!is_correct_price(price))
		    	throw std::invalid_argument("price is incorrect");
		    	
	    	_price = price;
    	}
    private:
    	bool is_correct_price(int price) const
    	{
	    	if(price >= 0)
		    	return true;
		    	
	    	return false;
    	}
    private:
    	int _price;
    public:
    	std::vector< std::string > lProp; 
    };


----------
**Структура каталогов**

Каждый класс находится в отдельной папке, кроме случаев когда классы тесно связанны друг с другом, тогда набор этих классов лежит в одной папке.

Ресурсы лежат в папке resourses в корне проекта, внутри этой папки находятся папки характеризующие собой категории ресурсов icons, logos, splashes.

----------
**Общие положения по коду:**

Длинна одной строки - не более 80 символов. 
Сначала понятность и очевидность, потом длинна!

Так не надо, на маленьком примере это выглядит красиво, а вот в большой функции легко запутаться

    while(i < 10)
    {
	    array[i++] = i+1; 
    }
Вот так можно

    while(i < 10)
    {
	    array[i] = i;
	    i++;
    }

Код должен описывать семантику, а не набор команд **как-то** выполняющий свою работу.

Функция должна быть чистой! А значит большинство функцию должно принимать константную ссылку. За исключением легких типов int, double и т. д.

Если требуется испортить объект, я советую принимать его по указателю, а не по ссылке, так как это явно заставит программиста использующего эту функцию указать что он ее передает для изменения

 Так программист не видит изменится ли его объект

    void sort(std::vector< int >& vec)
    { ... }
    
    int main()
    {
	    std::vector< int > vec = {1, 3, 2};
	    sort(vec);
	    
	    return 0;
    }

А вот так видит

    void sort(std::vector< int >* vec)
    { ... }
    
    int main()
    {
	    std::vector< int > vec = {1, 3, 2};
	    sort(&vec);
	    
	    return 0;
    }

